<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c3{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c0{orphans:2;widows:2}.c2{height:11pt}.c1{text-indent:36pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c3"><p class="c0"><span>if (m_fileName.substr(m_fileName.find_last_of(&quot;.&quot;) + 1) == &quot;jpg&quot;) {<br> &nbsp; &nbsp;struct jpeg_decompress_struct cinfo;<br> &nbsp; &nbsp;struct jpeg_error_mgr jerr;<br> &nbsp; &nbsp;FILE * infile;<br> &nbsp; &nbsp;JSAMPARRAY buffer;<br> &nbsp; &nbsp;int row_width;<br> &nbsp; &nbsp;cinfo.err = jpeg_std_error(&amp;jerr);<br><br> &nbsp; &nbsp;// Open the file<br> &nbsp; &nbsp;if ((infile = fopen(myFileName, &quot;rb&quot;)) == NULL) {<br> &nbsp; &nbsp; &nbsp;fprintf(stderr, &quot;can&#39;t open %s\n&quot;, myFileName);<br> &nbsp; &nbsp; &nbsp;return;<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;jpeg_create_decompress(&amp;cinfo);<br> &nbsp; &nbsp;jpeg_stdio_src(&amp;cinfo, infile);<br> &nbsp; &nbsp;(void) jpeg_read_header(&amp;cinfo, FALSE);<br> &nbsp; &nbsp;(void) jpeg_start_decompress(&amp;cinfo);<br> &nbsp; &nbsp;row_width = cinfo.output_width * cinfo.output_components;<br> &nbsp; &nbsp;buffer = (*cinfo.mem-&gt;alloc_sarray) ((j_common_ptr) &amp;cinfo, JPOOL_IMAGE, row_width, 1);<br> &nbsp; &nbsp;newBuf = new PixelBuffer(cinfo.output_width,cinfo.output_height,ColorData(1,1,1));<br><br> &nbsp; &nbsp;// Set the pixel in the temporary PixelBuffer to the information stored in the JSAMPARRAY buffer<br> &nbsp; &nbsp;while (cinfo.output_scanline &lt; cinfo.output_height) {<br> &nbsp; &nbsp; &nbsp;(void) jpeg_read_scanlines(&amp;cinfo, buffer, 1);<br> &nbsp; &nbsp; &nbsp;for (i=0;i&lt;cinfo.output_width;i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; newBuf-&gt;setPixel(i,cinfo.output_height-cinfo.output_scanline,ColorData(((float) buffer[0][3*i])/255,((float) buffer[0][3*i+1])/255,((float) buffer[0][3*i+2])/255));<br> &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;// Modify the main display PixleBuffer<br> &nbsp; &nbsp;canvasWidth = cinfo.output_width;<br> &nbsp; &nbsp;canvasHeight = cinfo.output_height;<br> &nbsp; &nbsp;setWindowDimensions(cinfo.output_width,cinfo.output_height);<br> &nbsp; &nbsp;m_displayBuffer = newBuf;<br> &nbsp; &nbsp;(void) jpeg_finish_decompress(&amp;cinfo);<br> &nbsp; &nbsp;jpeg_destroy_decompress(&amp;cinfo);<br> &nbsp; &nbsp;fclose(infile);<br> &nbsp;}</span></p><p class="c0 c2"><span></span></p><p class="c0 c1"><span>Most of this code was actually taken pretty much verbatim from the example files in the jpeg library. &nbsp;However, while the code from the library served as a good framework for this code, it needed to be modified to serve our purposes.</span></p><p class="c0 c1"><span>What this code does is first opens a .jpg file, and creates a lot of necessary structures to read the file. &nbsp;After opening the file, it can&rsquo;t simply read it, as .jpg files are compressed to use less space when stored, so it needs to be decompressed before it can be read. &nbsp;Thus, the program uses a decompress struct, cinfo, and first initializes it. &nbsp;Then, it reads the header out of the file, but doesn&rsquo;t do anything with it because we don&rsquo;t need it. &nbsp;After that, it starts the decompression process. &nbsp;At this point, we can get the dimensions of the image as cinfo.output_width and cinfo.output height, which allows us to read the image line by line and transfer it into the struct. &nbsp;First, however, we allocate a new PixelBuffer object with dimensions that match the image and a buffer object to hold the temporary read lines. &nbsp;After this, we use a loop to read the lines of the image. &nbsp;Inside this loop, we read a line, which stores the data in buffer[0] and take the rgb data from buffer[0] and use it to save the line in the new PixelBuffer object. &nbsp;After this, we modify the canvas and window dimensions to match the new image and set m_displayBuffer as the new PixelBuffer.</span></p><p class="c0 c1"><span>Now, as I stated at the beginning, the framework of the code was provided to us, but it was by no means easy to get this to work. &nbsp;Having the code was one thing, understanding it was another entirely. &nbsp; &nbsp;We left most of it untouched, but needed to figure out what was going on to know what to modify and how to do so to get useful information from it. &nbsp;It wasn&rsquo;t too difficult to figure out what was going on up until the point where I needed to get the information out of the JSAMPARRAY object buffer. &nbsp;It made enough sense that we had to decompress the image and read it line-by-line, but the structure of buffer was not obvious, the documentations was not helpful in understanding it, and searching online for an explanation of how to get the rgb data from buffer was utterly fruitless. &nbsp;I kept seeing them reference buffer[0], but not really using it or using other library calls which I did not understand. &nbsp;However, after noticing that multiple sources used buffer[0], I made a guess that buffer[0] was the array of rgb pixels such that buffer[0][0], buffer[0][1], and buffer[0][2] correspond to the r, g, and b values of the first pixel. &nbsp;I tried it out and found that it was correct. &nbsp;It was a frustrating process to figure out, especially since we were given a lot of library data and needed to extract the specific knowledge we needed, but with a little time and help from google, I got it to work.</span></p><p class="c0 c1"><span>From there, I just needed to change the window and canvas to accommodate the image and put the image into the window. &nbsp;To do this, I just changed the canvasWidth and canvasHeight, called setWindowDimensions, and set m_displayBuffer to be newBuf, the PixelBuffer that I stored the image in. &nbsp;</span></p><p class="c0 c1"><span>Once I got it preliminarily working, I had to fix a few things, like it loading upside down and being stretched out vertically. &nbsp;For the stretching, I realized I was augmenting one of the variables too often. &nbsp;For the loading upside down, I simply changed the location of the pixel to set in the reading loop to be cinfo.output_height-cinfo.output_scanline instead of cinfo.output_scanline.</span></p></body></html>
